<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on namkyujin.com</title><link>https://iamkyu.github.io/tags/java/</link><description>Recent content in java on namkyujin.com</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Sat, 09 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://iamkyu.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java, Call By Reference 에 대한 오해</title><link>https://iamkyu.github.io/post/20191109-java-call-by-reference/</link><pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate><guid>https://iamkyu.github.io/post/20191109-java-call-by-reference/</guid><description>Java, Call By Reference 에 대한 오해 이제까지 기본형은 Call By Value, 참조형은 Call By Reference로 막연히 알고 있었다. 그런데 생성자나 메서드를 통해 전달된 값을 사용할 때 오해하고 있는 부분이 있어 이를 정리한다.
결론부터 얘기하자면
Reference data type parameters, such as objects, are also passed into methods by value.
오라클의 Java Tutorials 문서 중 Passing Information to a Method or a Constructor를 살펴보면 위와 같이 서술되어 있다. 즉, 참조형 데이터 타입 역시 값으로 메소드에 전달된다는 것.</description></item><item><title>자바의 어노테이션</title><link>https://iamkyu.github.io/post/20170314-java-annotation/</link><pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate><guid>https://iamkyu.github.io/post/20170314-java-annotation/</guid><description>자바의 어노테이션 JDK1.5 부터 제공된 기능인 어노테이션은 @(;AT) 으로 시작하는 주석의 한 형태를 말한다. @Override, @SuppressWarnings(&amp;quot;&amp;quot;) 과 같은 어노테이션에 익숙할 것이다.
어노테이션은 메타데이터 한 형태로, 프로그램에 대한 정보를 제공하지만, 그 프로그램의 일부는 아니다. 어노테이션을 설정한 코드에 직접적인 영향을 미치지는 않는다.
Oracle의 자바 튜토리얼 문서에서 어노테이션을 위와 같이 정의하며 용도를 설명한다.
컴파일러를 위한 정보를 제공하기 위해. 컴파일 시점에 어떤 코드나 XML 파일 등을 생성하기 위해. 런타임 시점에 추가적인 처리를 하기 위해.</description></item><item><title>자바의 switch-case</title><link>https://iamkyu.github.io/post/20160901-java-switch-and-hash/</link><pubDate>Mon, 15 Aug 2016 00:00:00 +0000</pubDate><guid>https://iamkyu.github.io/post/20160901-java-switch-and-hash/</guid><description>switch-case 조건 분기를 해야 할 때, 경우에 따라 if-then-else 보다 switch-case를 잘 사용하면 훨씬 깔끔한 코드를 작성할 수 있다.
1int month = 3; 2String monthStr; 3 4switch (month) { 5 case 1: monthStr = &amp;#34;jan&amp;#34;; 6 break; 7 8 case 2: monthStr = &amp;#34;fab&amp;#34;; 9 break; 10 11 case 3: monthStr = &amp;#34;mar&amp;#34;; 12 break; 13 14 // .. 중략 1516default: monthStr = &amp;#34;Not valid&amp;#34;; 17 break; 18} 기존의 자바는 char, byte, short, int와 같은 기본형 타입에 대해서만 switch-case 사용이 가능했지만 JDK7 이후 버전부터는 String형 사용이 가능해졌다.</description></item><item><title>자바에서 문자를 구분자로 분리하기</title><link>https://iamkyu.github.io/post/20160716-java-split/</link><pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate><guid>https://iamkyu.github.io/post/20160716-java-split/</guid><description>자바에서 문자를 구분자로 분리하기 셀렉트리스트의 하나의 옵션에 여러 값(Value)을 줘야 할 경우 보통 구분자(delimiter)를 넣어두고 그 구분자를 기준으로 하여 하나의 값을 여러 값으로 분리해내는 방식을 사용한다.
1&amp;lt;body&amp;gt; 2&amp;lt;select id=&amp;#34;select_list&amp;#34;&amp;gt; 3 &amp;lt;option value=&amp;#34;APPLE|CARROT|PIZZA&amp;#34;&amp;gt;Foods&amp;lt;/option&amp;gt; 4&amp;lt;/select&amp;gt; 5 6&amp;lt;script&amp;gt; 7var options = $(&amp;#34;#select_list option:selected&amp;#34;).val(); 8var values = options.split(&amp;#34;|&amp;#34;); 9 10var params = &amp;#34;?FRUIT=&amp;#34; + values[0] 11 params += &amp;#34;&amp;amp;VEGETABLE=&amp;#34; + values[1] 12 params += &amp;#34;&amp;amp;INSTANT=&amp;#34; + values[2]; 13 14/* 15values[0] = &amp;#34;APPLE&amp;#34; 16values[1] = &amp;#34;CARROT&amp;#34; 17values[2] = &amp;#34;PIZZA&amp;#34; 18*/ 19&amp;lt;/script&amp;gt; 20&amp;lt;/body&amp;gt; 주로 클라이언트측에서 특정 조건 값으로 조회(SELECT)를 할 때 위와 같이 view 단에서 자바스크립트를 통해 아예 다 분리를 한 다음 쿼리스트링을 만들어 HTTP GET 요청을 보냈다.</description></item></channel></rss>